module a_cam_32x32 (
    input  wire        clk,
    input  wire        rst,
    input  wire        start,
    input  wire [31:0] a,
    input  wire [31:0] b,
    output reg  [63:0] result,
    output reg         done,
    output reg         busy
);

    reg [31:0] opA, opB;
    reg [63:0] accumulator;

    reg [2:0] i, j;
    reg [6:0] cycle_count;     // 0 to 66 (64 ops + 2 flush)

    reg [2:0] i_d1, j_d1;
    reg [2:0] i_d2, j_d2;

    reg [1:0] valid_pipe;

    wire [3:0] a_chunk;
    wire [3:0] b_chunk;
    wire [7:0] cam_product;
    wire       cam_ready;

    assign a_chunk = (opA >> (i*4)) & 4'hF;
    assign b_chunk = (opB >> (j*4)) & 4'hF;

    a_cam_4x4 u_cam (
        .clk(clk),
        .rst(rst),
        .a(a_chunk),
        .b(b_chunk),
        .product(cam_product),
        .hit(),
        .match_addr(),
        .init_done(cam_ready)
    );

    localparam IDLE = 1'b0,
               RUN  = 1'b1;

    reg state;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE;
            busy <= 0;
            done <= 0;
            accumulator <= 0;
            result <= 0;
            i <= 0;
            j <= 0;
            cycle_count <= 0;
            valid_pipe <= 0;
        end
        else begin
            done <= 0;

            case (state)

            //---------------------------------
            IDLE:
            //---------------------------------
            begin
                busy <= 0;
                if (start && cam_ready) begin
                    busy <= 1;
                    accumulator <= 0;
                    opA <= a;
                    opB <= b;
                    i <= 0;
                    j <= 0;
                    cycle_count <= 0;
                    valid_pipe <= 0;
                    state <= RUN;
                end
            end

            //---------------------------------
            RUN:
            //---------------------------------
            begin
                // pipeline indices
                i_d1 <= i;
                j_d1 <= j;
                i_d2 <= i_d1;
                j_d2 <= j_d1;

                // valid only during first 64 cycles
                valid_pipe <= {valid_pipe[0], (cycle_count < 64)};

                // accumulate when valid emerges
                if (valid_pipe[1]) begin
                    accumulator <= accumulator +
                        ({56'd0, cam_product} << (4*(i_d2 + j_d2)));
                end

                // generate 64 combinations
                if (cycle_count < 64) begin
                    if (j == 3'd7) begin
                        j <= 0;
                        i <= i + 1;
                    end
                    else begin
                        j <= j + 1;
                    end
                end

                cycle_count <= cycle_count + 1;

                // finish after flush
                if (cycle_count == 66) begin
                    result <= accumulator;
                    busy <= 0;
                    done <= 1;
                    state <= IDLE;
                end
            end

            endcase
        end
    end

endmodule
